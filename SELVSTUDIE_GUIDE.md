# üöÄ dbt Selvstudie - L√¶r ved √• oppdage!

## Hvordan bruke denne guiden

Dette er ikke en vanlig instruksjonsmanual. Du kommer til √• **oppdage** dbt-konseptene ved √•:
- üîç Utforske eksisterende kode
- ü§î Stille deg sp√∏rsm√•l underveis  
- üß™ Eksperimentere med endringer
- ‚úÖ Besvare kontrollsp√∏rsm√•l

## üìö L√¶ringsl√∏ypen

> **üí° Pro-tips for effektiv l√¶ring:**
> - Ta pauser mellom moduler for √• la konseptene synke inn
> - Eksperimenter fritt - du kan alltid starte p√• nytt
> - Skriv ned refleksjoner og "aha-√∏yeblikk"
> - Diskuter med kolleger hvis mulig

### Oversikt over modulene
```
Modul 1: Utforsk prosjektet (15 min) ‚îÄ‚îÄ‚îê
                                        ‚îÇ
Modul 2: F√∏rste modell (20 min) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
                                        ‚îú‚îÄ‚Üí Grunnleggende dbt
Modul 3: Staging (25 min) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
                                        ‚îÇ
Modul 4: Sources (20 min) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Modul 5: Ref-funksjonen (20 min) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                                        ‚îú‚îÄ‚Üí Avansert dbt
Modul 6: Testing (15 min) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

### Modul 1: Utforsk dbt-prosjektet
**Tid: 15 minutter**

#### üîç Oppdagelsesoppgave
F√∏r du begynner, utforsk repositoriet:

**Refleksjonssp√∏rsm√•l:**
- [ ] Hvilke mapper ser du i `intro_kurs/`?
- [ ] Hva tror du `dbt_project.yml` inneholder?
- [ ] Hvilke typer filer finner du i `models/`?

#### üí° Mini-utfordring
√Öpne terminalen og naviger til `intro_kurs`. Kj√∏r:
```bash
dbt --help
```
**Sp√∏rsm√•l:** Hvilke kommandoer ser mest nyttige ut for deg?

---

### Modul 2: Din f√∏rste modell - Oppdage m√∏nsteret
**Tid: 20 minutter**

#### üéØ L√¶ringsm√•l
Du skal oppdage hvordan dbt transformerer data ved √• bygge din f√∏rste modell.

#### üîç Start med utforsking
1. Se p√• data i kildetabellene f√∏rst:
```sql
-- Kj√∏r dette i duckdb eller din database
SELECT * FROM jaffle_shop.customers LIMIT 5;
SELECT * FROM jaffle_shop.orders LIMIT 5;
```

**Verifiser i databasen:**
```bash
# I VS Code terminal eller DuckDB CLI
duckcli dev.duckdb
# Kj√∏r:
SELECT * FROM jaffle_shop.customers LIMIT 5;
```

**Refleksjonssp√∏rsm√•l:**
- [ ] Hvilke felter ser du i hver tabell?
- [ ] Hvordan kan disse tabellene kobles sammen?
- [ ] Hva slags informasjon mangler for √• f√• et komplett kundebilde?

#### üß™ Bygg og eksperimenter

**Steg 1: Forst√• strukturen**
F√∏r du skriver koden, tenk over:
- Hva er en CTE (Common Table Expression)?
- Hvorfor dele opp SQL i flere `with`-blokker?
- Hva er fordelen med `final` CTE?

**Steg 2: Lag filen**
Opprett `models/dim_customer.sql` med denne koden:

```sql
with customers as
(
    select
        id as customer_id,
        first_name as name
    from jaffle_shop.customers
),
orders as (
    select
        id as order_id,
        user_id as customer_id,
        order_date as ordered_at
    from jaffle_shop.orders
),
customer_orders as (
    select
        customer_id,
        min(ordered_at) as first_order_date,
        max(ordered_at) as most_recent_order_date,
        count(order_id) as number_of_orders
    from orders
    group by customer_id
),
final as (
    select
        customers.customer_id,
        customers.name,
        customer_orders.first_order_date,
        customer_orders.most_recent_order_date,
        coalesce(customer_orders.number_of_orders, 0) as number_of_orders
    from customers
    left join customer_orders on customers.customer_id = customer_orders.customer_id
)

select * from final
```

**Steg 3: Kj√∏r modellen**
```bash
cd intro_kurs
dbt run --select dim_customer
```

#### ‚ùì Kontrollsp√∏rsm√•l
Etter at du har kj√∏rt `dbt run --select dim_customer`:

**Utforsk resultatet:**
```bash
dbt show -s dim_customer
```

**Reflekter:**
1. **Hvor mange rader fikk du?** ___ (Tips: Skal matche antall kunder)
2. **Finn kunden med flest bestillinger** - Hvilke verdier ser du?
3. **Hva skjer med kunder som aldri har bestilt?** (Se p√• `number_of_orders`)
4. **Hvorfor bruker vi `coalesce()` funksjonen?**

**Verifiser i databasen:**
```bash
# I VS Code terminal eller DuckDB CLI
duckcli dev.duckdb
# Kj√∏r:
SELECT * FROM main.dim_customer ORDER BY number_of_orders DESC LIMIT 5;
```

#### üèÜ Utfordring
Kan du legge til et felt som viser hvor mange dager det er siden siste bestilling?

---

### Modul 3: Staging - Oppdage kildeabstraksjon
**Tid: 25 minutter**

#### ü§î Reflekter f√∏rst
Se p√• `dim_customer.sql` du nettopp laget. 

**Sp√∏rsm√•l:**
- Hva hvis tabellnavnet `jaffle_shop.customers` endres?
- Hva hvis du vil dokumentere hvor dataene kommer fra?
- Hvordan kan du gj√∏re koden mer gjenbrukbar?

#### üîç Oppdag staging-m√∏nsteret
Les dette sitatet fra dbt-dokumentasjonen:
> "Staging models are the foundation of your project"

**F√∏r du lager staging-modeller, tenk:**
- [ ] Hva er forskjellen p√• "r√• data" og "klargjort data"?
- [ ] Hvilke transformasjoner b√∏r skje tidlig vs sent i prosessen?

#### üß™ Lag dine f√∏rste staging-modeller

**Oppgave 1: Staging for customers**

Opprett filen `models/staging/stg_customers.sql`:

```sql
with customers_stg as (
    select 
        id as customer_id,
        first_name,
        last_name,
        first_name || ' ' || last_name as name
    from jaffle_shop.customers
)

select * from customers_stg
```

Kj√∏r modellen:
```bash
dbt run --select stg_customers
```

**Oppgave 2: Staging for orders**

Opprett filen `models/staging/stg_orders.sql`:

```sql
with orders_stg as (
    select 
        id as order_id,
        user_id as customer_id,
        order_date as ordered_at,
        _etl_loaded_at
    from jaffle_shop.orders
)

select * from orders_stg
```

Kj√∏r modellen:
```bash
dbt run --select stg_orders
```

#### üí° Oppdagelsesmoment
Etter du har laget begge staging-modellene, kj√∏r:
```bash
dbt run --select staging
```

**Reflekter:**
- [ ] Hvor mange modeller ble bygget?
- [ ] I hvilken rekkef√∏lge ble de bygget?
- [ ] Hvordan ser dataene ut n√• sammenlignet med r√•data?

---

### Modul 4: Sources - Oppdage kildeabstraksjon
**Tid: 20 minutter**

#### üéØ Probleml√∏sning
Du har sikkert lagt merke til at du hardkoder tabellnavn. Hva om:
- Databasen heter noe annet i prod?
- Du vil teste datakvalitet p√• kildene?
- Du vil dokumentere hvor data kommer fra?

#### üîç Utforsk source-konseptet
F√∏r du implementerer, se p√• denne koden:
```sql
from {{ source('jaffle_alle', 'customers') }}
```

**Gjett:**
- [ ] Hva tror du `jaffle_alle` refererer til?
- [ ] Hvor tror du denne informasjonen defineres?
- [ ] Hvilke fordeler gir denne tiln√¶rmingen?

#### üß™ Implementer sources

**Steg 1: Definer sources**

Lag filen `models/staging/src_jaffle_shop.yml`:

```yaml
sources:
  - name: jaffle_alle
    description: Treningsdatabase DuckDB
    database: dev
    schema: jaffle_shop
    tables:
      - name: orders
        description: Alle ordrene
        freshness:
          warn_after:
            count: 1
            period: day
        loaded_at_field: "CAST(order_date AS TIMESTAMP)"
      - name: customers
        description: Kundene v√•re
        columns:
          - name: id
            description: Primary key
            tests:
              - unique
              - not_null
  - name: stripe
    database: dev
    schema: stripe
    tables:
      - name: payment
        description: Betalinger utf√∏rt
```

**Steg 2: Oppdater staging-modeller til √• bruke sources**

Endre `stg_customers.sql` til:

```sql
with customers_stg as (
    select 
        id as customer_id,
        first_name,
        last_name,
        first_name || ' ' || last_name as name
    from {{ source('jaffle_alle', 'customers') }}
)

select * from customers_stg
```

Endre `stg_orders.sql` til:

```sql
with orders_stg as (
    select 
        id as order_id,
        user_id as customer_id,
        order_date as ordered_at,
        _etl_loaded_at
    from {{ source('jaffle_alle', 'orders') }}
)

select * from orders_stg
```

**Steg 3: Test det!**

```bash
# Kj√∏r modellene p√• nytt
dbt run --select staging

# Kj√∏r source-tester
dbt test --select source:jaffle_alle

# Sjekk data-ferskhet
dbt source freshness
```

#### ‚ùì Eksperimenter og l√¶r
1. Oppdater `stg_customers.sql` til √• bruke `{{ source() }}`
2. Kj√∏r `dbt run --select stg_customers`
3. Kj√∏r `dbt test` - hva skjer?

**Refleksjonssp√∏rsm√•l:**
- [ ] Hvorfor feilet noen tester?
- [ ] Hvordan kan du fikse dem?
- [ ] Hva er verdien av √• teste p√• kildeniv√•?

---

### Modul 5: Ref-funksjonen - Oppdage avhengigheter
**Tid: 20 minutter**

#### üîÑ Refaktorer dim_customer
N√• skal du oppdage kraften i `{{ ref() }}` funksjonen.

**F√∏r du starter:**
- [ ] Hvordan kan `dim_customer` bruke staging-modellene du laget?
- [ ] Hva skjer hvis du endrer en staging-modell?
- [ ] Hvordan vet dbt hvilke modeller som m√• kj√∏res f√∏rst?

#### üß™ Oppdater fak_customer_orders.sql

**Steg 1: Opprett marts-mappen**
```bash
mkdir -p models/marts
```

**Steg 2: Lag modellen**

Opprett `models/marts/fak_customer_orders.sql`:

```sql
with
    customers as (
        select * from {{ ref('stg_customers') }}
    ),
    orders as (
        select * from {{ ref('stg_orders') }}
    ),
    customer_orders as (
        select
            customer_id,
            min(ordered_at) as first_order_date,
            max(ordered_at) as most_recent_order_date,
            count(order_id) as number_of_orders
        from orders
        group by customer_id
    ),
    final as (
        select
            customers.customer_id,
            customers.name,
            customer_orders.first_order_date,
            customer_orders.most_recent_order_date,
            coalesce(customer_orders.number_of_orders, 0) as number_of_orders
        from customers
        left join customer_orders 
            on customers.customer_id = customer_orders.customer_id
    )

select * from final
```

**Steg 3: Kj√∏r med avhengigheter**

```bash
# Kj√∏r modellen MED alle avhengigheter (upstream)
dbt run --select +fak_customer_orders

# Se hva som ble kj√∏rt
dbt ls --select +fak_customer_orders
```

#### üí° Test avhengigheter
Kj√∏r disse kommandoene og observer:
```bash
dbt run --select +fak_customer_orders  # Hva betyr + ?
dbt run --select fak_customer_orders+  # Hva betyr + her?
dbt run --select +fak_customer_orders+ # Og her?
```

**Oppdagelsesnotat:**
- [ ] I hvilken rekkef√∏lge kj√∏rte modellene?
- [ ] Hva skjedde med staging-modellene?

---

### Modul 6: Testing og dokumentasjon
**Tid: 15 minutter**

#### ü§î Kvalitetssp√∏rsm√•l
- Hvordan vet du at dataene dine er korrekte?
- Hva hvis det kommer duplikater i kildedataene?
- Hvordan dokumenterer du hva modellene gj√∏r?

#### üß™ Lag `mdl_jaffle_shop.yml`

**F√∏r du starter: Tenk over hva som skal testes**
- Hvilke felter kan ALDRI v√¶re null?
- Hvilke felter skal ALLTID v√¶re unike?
- Hvilke forretningsregler m√• holde?

**Opprett filen `models/staging/mdl_jaffle_shop.yml`:**

```yaml
version: 2

models:
  - name: stg_orders
    description: "Alle ordrene fra kildesystemet, klargjort for videre bruk"
    columns:
      - name: order_id
        description: "Ordre-ID som er unik og kan ikke v√¶re null"
        tests:
          - unique
          - not_null
      - name: customer_id
        description: "Referanse til kunde"
        tests:
          - not_null
          
  - name: stg_customers
    description: "Alle kundene som bestiller varer"
    columns:
      - name: customer_id
        description: "Kunde-ID m√• v√¶re unik og kan ikke v√¶re null"
        tests:
          - unique
          - not_null
      - name: name
        description: "Fullt navn p√• kunden"
        tests:
          - not_null
```

**Kj√∏r testene:**
```bash
# Test alle modeller
dbt test

# Test bare staging-modeller
dbt test --select staging

# Test en spesifikk modell med avhengigheter
dbt test --select +fak_customer_orders
```

**Feils√∏k hvis tester feiler:**
```bash
# F√• mer detaljert output
dbt test --select stg_customers --debug

# Se hvilke rader som feilet
dbt test --select stg_customers --store-failures
```

#### ‚ùì Test og l√¶r
```bash
dbt test --select +fak_customer_orders
```

**Hvis tester feiler:**
- [ ] Les feilmeldingen n√∏ye - den forteller deg hva som er galt
- [ ] Sjekk hvilken test som feiler (unique, not_null, etc.)
- [ ] Unders√∏k dataene for √• finne √•rsaken
- [ ] Fiks enten testen eller datalogikken

**Vanlige feil og l√∏sninger:**

1. **"FAIL unique test"** 
   - Betyr: Du har duplikater
   - Fiks: Finn duplikatene med `SELECT ..., COUNT(*) GROUP BY ... HAVING COUNT(*) > 1`

2. **"FAIL not_null test"**
   - Betyr: Du har NULL-verdier
   - Fiks: Sjekk `WHERE <kolonne> IS NULL` og h√•ndter dem

3. **Test feiler p√• freshness**
   - Betyr: Data er eldre enn forventet
   - Dette er OK i √∏velsesdata - du kan justere terskelverdiene

---

## üîß Feils√∏king og debugging

### Nyttige kommandoer n√•r noe g√•r galt

**Kompilere uten √• kj√∏re:**
```bash
dbt compile --select dim_customer
# Sjekk compiled SQL i target/compiled/
```

**Se SQL f√∏r den kj√∏res:**
```bash
dbt show -s dim_customer --limit 5
```

**F√• mer detaljert output:**
```bash
dbt run --select dim_customer --debug
```

**Sjekk avhengigheter:**
```bash
# Se alle modeller som dim_customer avhenger av
dbt ls --select +dim_customer

# Se alle modeller som avhenger av stg_customers  
dbt ls --select stg_customers+
```

**Rydd opp og start p√• nytt:**
```bash
dbt clean
dbt deps  # Hvis du bruker packages
dbt run
```

### Visualiser ditt arbeid med dbt docs

**Generer dokumentasjon:**
```bash
dbt docs generate
dbt docs serve
```

Dette √•pner en interaktiv webside hvor du kan:
- üìä Se alle modeller og deres dokumentasjon
- üîó Utforske datalineage (hvem bruker hva)
- üìù Lese kolonnebeskrivelser
- üß™ Se hvilke tester som finnes

**Utforsk lineage-grafen:**
- Klikk p√• en modell (f.eks. `fak_customer_orders`)
- Se hvordan data flyter fra sources ‚Üí staging ‚Üí marts
- Forst√• avhengigheter visuelt

---

## üéâ Avslutning og refleksjon

### üèÜ Hva har du oppn√•dd?

Gratulerer! Du har n√•:
- ‚úÖ Bygget dine f√∏rste dbt-modeller
- ‚úÖ Forst√•tt staging-konseptet og kildeabstraksjon
- ‚úÖ Implementert sources og ref() funksjoner
- ‚úÖ Satt opp datakvalitetstesting
- ‚úÖ Dokumentert dine modeller
- ‚úÖ Utforsket datalineage

### ü§î Refleksjonssp√∏rsm√•l

**Teknisk forst√•else:**
- [ ] Kan du forklare forskjellen p√• `source()` og `ref()` med egne ord?
- [ ] Hvorfor er staging-lag viktig i et dbt-prosjekt?
- [ ] N√•r ville du brukt `table` vs `view` materialisering?

**Praktisk anvendelse:**
- [ ] Hvordan ville du strukturert et dbt-prosjekt fra scratch?
- [ ] Hvilke tester er mest kritiske √• implementere f√∏rst?
- [ ] Hvordan vil du bruke dbt i ditt eget arbeid?

### üìä Sjekk ditt arbeid

**Verifiser at alt fungerer:**
```bash
# Kj√∏r alt fra scratch
dbt clean
dbt run
dbt test
dbt docs generate
```

**Forventet resultat:**
- Alle modeller kj√∏rer uten feil
- Alle tester passerer (eller du forst√•r hvorfor de feiler)
- Dokumentasjon genereres korrekt

### üéØ Neste steg
- Utforsk dbt dokumentasjon: `dbt docs generate && dbt docs serve`
- Eksperimenter med egne data
- Bli med i dbt community!

---

## üìù Notater og refleksjoner
*Bruk dette omr√•det til √• skrive ned tanker underveis...*
